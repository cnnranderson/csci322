\documentclass{article}
\sloppy
%\usepackage[margin=0.5in]{geometry}
%\usepackage[landscape,margin=0.5in]{geometry}
\usepackage[landscape,top=-1in,left=0.5in,right=0.5in,bottom=0.0in]{geometry}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{overpic}

\usepackage{fancyvrb}
\setlength{\parindent}{0in}


\newcommand{\nop}[1]{}
\newcommand{\myfig}[1]{\newpage\begin{overpic}[scale=1.5]{figures/#1}}
\newcommand{\myfigs}[2]{\newpage\begin{overpic}[scale=#1]{figures/#2}}
\newcommand{\myfigsp}[3]{\newpage\begin{overpic}[scale=#1,page=#2]{figures/#3}}
\newcommand{\myfigend}{\end{overpic}}
\newcommand{\myput}[2]{\put(10,#1){$\bullet$ #2}}
\newcommand{\myputn}[2]{\put(15,#1){#2}}

\newcommand{\bi}{\begin{itemize}}
\newcommand{\ii}{\item}
\newcommand{\ei}{\end{itemize}}
\newcommand{\ti}[1]{
\newpage
\mbox{~}

\vspace{1.25in}
\centerline{\bf #1}
}

\newcommand{\la}{\ensuremath{\langle}}
\newcommand{\ra}{\ensuremath{\rangle}}


\RecustomVerbatimEnvironment
  {Verbatim}{Verbatim}
  {frame=single,commandchars=\\\{\}}

\begin{document}


\huge\sf

\ti{Distributed Programming}

\bi
\ii Distributed memory architectures.
\ii Concurrent programs here are usually called {\em distributed} programs.
\ii No shared variables.
\bi\ii No mutual exclusion necessary!\ei
\ii Communicate and synchronize with {\em channels}:
\bi
\ii one-way or two-way
\ii synchronous (blocking) or asynchronous (nonblocking)
\ei
\ii Four basic mechanisms:
\bi
\ii Chapter 7:
\bi
\ii asynchronous message passing
\ii synchronous message passing
\ei
\ii Chapter 8:
\bi
\ii RPC (remote procedure call)
\ii rendezvous
\ei
\ei
\ii Chapter 9 describes several paradigms for distributed programming:
\bi\ii managers/workers, hearbeat, pipeline, probe/echo, broadcast, \\
token passing, decentralized servers\ei
\ei

\myfig{000_II_1.pdf}
\myput{60}{Monitors combine implicit exclusion with explicit signalling}
\myput{57}{Message passing adds data to semaphore}
\myput{54}{RPC and Rendezvous combine procedural interface of monitors}
\myputn{52}{with implicit message passing}
\myfigend


\ti{Message Passing}
\centerline{Andrews, Chapter 07}

\bi
\ii Asynchronous message passing: channels are like semaphores.
\ii {\tt send} and {\tt receive} are like {\tt V} and {\tt P}
\ii {\tt receive} is {\em blocking}
\ii May want to avoid blocking:  {\tt empty(ch)}
\bi\ii use with caution:  may be unreliable\ei
\ii The number of queued ``messages'' is the value of the semaphore.
\ii We assume messages are atomic and delivery is reliable and
error-free. 
\ei

\myfig{7_01.pdf}
\myput{50}{Channels like this are called {\em mailboxes}}
\myfigend

\ti{Filters: Sorting}
\begin{Verbatim}
process Sort \{
  \mbox{\rm receive all numbers from channel} input;
  \mbox{\rm sort the numbers};
  \mbox{\rm send the sorted numbers to channel} output;
\}
\end{Verbatim}
\bi
\ii Suitable for ``heavyweight'' processes.
\ii Alternative: network of lightweight {\em merge} processes.
\ei

\myfig{7_02.pdf}
\myfigend
\myfig{7_03.pdf}
\myput{60}{Original values can be lists sorted by ``mediumweight''
  processes.} 
\myfigend
\myfig{7_04.pdf}
\myfigend
\myfig{7_05.pdf}
\myfigend
\myfig{7_06.pdf}
\myfigend
\myfigs{1.25}{7_07.pdf}
\myfigend
\myfig{table7_1.pdf}
\myfigend
\myfig{7_08.pdf}
\myfigend
\myfigs{1.4}{7_09.pdf}
\myfigend
\myfigs{1.2}{7_10.pdf}
\myfigend
\myfig{7_11.pdf}
\myfigend
\myfig{7_12.pdf}
\myfigend
\myfig{7_13.pdf}
\myfigend
\myfig{7_14.pdf}
\myfigend
\myfig{p318_pc_synchmp.pdf}
\myfigend
\myfig{p320_exchange_synchmp.pdf}
\myfigend
\myfig{p322_GCD_csp.pdf}
\myfigend
\myfig{p324_copy_csp.pdf}
\myfigend
\myfig{p325_allocator_csp.pdf}
\myfigend
\myfig{p326_exchange_csp.pdf}
\myfigend
\myfig{7_15.pdf}
\myfigend
\myfig{p330_pc_occam.pdf}
\myfigend
\myfig{p331_copy_occam.pdf}
\myfigend
\myfig{p333_modernCSP.pdf}
\myfigend


\myfigsp{.9}{1}{7_16.pdf}
\myfigend
\myfigsp{.9}{2}{7_16.pdf}
\myfigend

\myfig{7_17.pdf}
\myfigend
\myfigs{1.1}{7_18.pdf}
\myfigend
\myfigs{1.3}{7_19.pdf}
\myfigend
\end{document}
